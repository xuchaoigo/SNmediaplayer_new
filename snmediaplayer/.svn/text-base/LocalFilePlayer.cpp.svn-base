#include "LocalFilePlayer.h"
#include "utf8_gb2312.h"
#include "DSP_graphics_api.h"
LocalFilePlayer::LocalFilePlayer(int instanceid,int videoDisplayMode, int playmode,
	int height, int width, int left, int top, int muteFlag,  int muteuiflag, int subtitleFlag, 	
	int videoAlpha, int cycleFlag, int randomFlag, int autoDelFlag,string json_str,	
	int useNativeUIFlag,int audioVolumeUIFlag,int audioTrackUIFlag,int progressBarUIFlag,	
	int channelNoUIFlag,int allowTrickmodeFlag,int speed,int volume,int pipmode,	
	MediaplayerStateChangeCallback playstate_func)
{
	real_instanceid=instanceid;
	real_json_str=json_str;	
	real_playmode=playmode;
	real_videoDisplayMode=videoDisplayMode;
	real_videoDisplayrect.x=left;
	real_videoDisplayrect.y=top;
	real_videoDisplayrect.height=height;
	real_videoDisplayrect.width=width;
	real_muteflag=muteFlag;//0:  设置为有声 (默认值);1:  设置为静音
	real_nativeUIFlag=useNativeUIFlag;//0: 不使能Player的本地UI显示功能;1: 使能Player的本地UI显示功能 (默认值)
	real_muteUIFlag=muteuiflag;//: 不使能静音提示的本地UI显示功能;1: 使能静音提示的本地UI显示功能（默认值）	
	real_audioVolumeUIFlag=audioVolumeUIFlag;//0: 不使能音量调节的本地UI显示功能;1: 使能音量调节的本地UI显示功能（默认值）
	real_audioTrackUIFlag=audioTrackUIFlag;//0: 不使能音轨选择的本地UI显示功能;1: 使能音轨选择的本地UI显示功能（默认值）
	real_progressBarUIFlag=progressBarUIFlag;//0: 不使能进度条的本地UI显示功能;1: 使能进度条的本地UI显示功能（默认值） 
	real_channelNoUIFlag=channelNoUIFlag;//0: 不使能频道号的本地UI显示功能;1: 使能频道号的本地UI显示功能（默认值）
	real_subtitileFlag=subtitleFlag;//0:	不显示字幕 (默认值);   1:  显示字幕
	real_videoAlpha=videoAlpha;//0－100之间的整数值，0表示不透明，100表示完全透明(默认值为0)
	real_allowTrickmodeFlag=allowTrickmodeFlag;//0－100之间的整数值，0表示不透明，100表示完全透明。(默认值为0)
	real_cycleFlag=cycleFlag;	
	real_randomFlag=randomFlag;
	real_autoDelFlag=autoDelFlag;
	real_speed=speed;//-32,-16,-8,-4,-2,0,...32	
	real_volume=volume;//0-100，表示音量，0为静音，100为最大音量
	real_pipmode=pipmode;
	real_playstate_func=playstate_func;

	local_playstate=PLAYERSTATE_PREINIT;
	local_duration=0;
	local_currenttime=0;
	local_mplayer_handle=-1;	
	getmediaurlfromjson();
	//msgid = msgget(LOCAL_MEDIAPLAYER_QUEUE_KEY,IPC_CREAT|0666);
	OpenPlayer();
	local_audiomode=DSPDualMode_Stereo;
	memset(&Playparms,0,sizeof(Playparms));

	memset(&line1,0,sizeof(line1));
	memset(&line2,0,sizeof(line2));
	suboffset=0;//字幕显示时间偏移
	yoffset=0;//y坐标偏移 -subfontheight or subfontheight;
	subfileSum=0;//record sub numbers
	subindex=1;/*显示事件用*/
	DSP_graphics_unSetBackGround();
}

LocalFilePlayer::~LocalFilePlayer()
{

	printf("~~LocalFilePlayer\n");
	stop();
}

int LocalFilePlayer::OpenPlayer()
{
	DSPFP_RETVALUE ret;
	printf("OpenPlayer,instance id is %d\n",real_instanceid);
	if(real_instanceid==0)//the first one is the  maindecoder
		ret=DSPFP_OpenPlayer(&local_mplayer_handle,1);
	else
		ret=DSPFP_OpenPlayer(&local_mplayer_handle,0);
	printf("DSP_FPOpenPlayer,ret is %d\n",ret);
	if(ret!=DSPFP_OK)
		return -1;

	ret=SetPlayerParam();
	printf("SetPlayerParam,ret is %d\n",ret);
	if(ret!=DSPFP_OK)
		return -1;
	ret=DSPFP_PlayFile(local_mplayer_handle);
	printf("DSPFP_PlayFile,ret is %d\n",ret);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_PLAYING;
	ret=DSPFP_Pause(local_mplayer_handle);
	printf("DSPFP_Pause,ret is %d\n",ret);
	if(ret==DSPFP_OK)
		local_playstate=PLAYERSTATE_PAUSED;
	return 0;
}
void LocalFilePlayer::player_setvolume(int volumeindex)
{	
	DSPFP_RETVALUE ret;

	if(local_mplayer_handle<=0)
		return;
	real_volume= volumeindex;
	ret=DSPFP_SetVolume(local_mplayer_handle,real_volume);
	return;
}

int LocalFilePlayer::ClosePlayer()
{
	if(local_mplayer_handle>0)
	{
		DSPFP_StopPlayer(local_mplayer_handle);
		DSPFP_ClosePlayer(local_mplayer_handle);
		local_mplayer_handle=-1;
	}
	return 0;
}
int LocalFilePlayer::getmediaurlfromjson()
{
	size_t fstart, fend;
	string tmp;
	strcpy(Playparms.url,"http://192.168.100.115/sitv.mpg");
	printf("get http://192.168.100.115/sitv.mpg!!\n");
	return 0;
	fstart=real_json_str.find("mediaUrl:\"");
	if (fstart!=string::npos)
	{	
		fstart+=strlen("mediaUrl:\"");
		fend=real_json_str.find("\"",fstart);
		if (fend!=string::npos)
		{
			tmp = real_json_str.substr(fstart,fend);
			strcpy(Playparms.url,tmp.c_str());
			cout<<"mediaurl is "<<Playparms.url<<endl;
			return 0;
		}
	}
	return -1;
}


DSPFP_RETVALUE LocalFilePlayer::SetPlayerParam()
{
	DSPFP_RETVALUE ret;
	printf("real_videoDisplayMode,real_videoDisplayMode is %d\n",real_videoDisplayMode);
	if(real_videoDisplayMode==0)
		Playparms.fullscreen=1;
	else
		Playparms.fullscreen=0;
	Playparms.loop=!real_cycleFlag;
	Playparms.playwindow.height=real_videoDisplayrect.height*PLAYER_Full_Win_HEGHT/DFB_OSD_HEIGHT;
	Playparms.playwindow.width=real_videoDisplayrect.width*PLAYER_Full_Win_WIDTH/DFB_OSD_WIDTH;
	Playparms.playwindow.x=real_videoDisplayrect.x*PLAYER_Full_Win_WIDTH/DFB_OSD_WIDTH;
	Playparms.playwindow.y=real_videoDisplayrect.y*PLAYER_Full_Win_HEGHT/DFB_OSD_HEIGHT;
	Playparms.play_audio=1;
	Playparms.starttime=local_playstarttime;
	Playparms.start_play=0;
	Playparms.volumeindex=real_volume;
	Playparms.video_ratio=0;
	getmediaurlfromjson();
	ret = DSPFP_LoadPlayparms(local_mplayer_handle, &Playparms);
	
	return ret;
}

int LocalFilePlayer::playFromStart()
{
	DSPFP_RETVALUE ret;
	local_playstarttime = 0;
	printf("playFromStart,handle is %d\n",local_mplayer_handle);
	if(local_mplayer_handle <=0)
	{	
		ret=SetPlayerParam();
		printf("SetPlayerParam,ret is %d\n",ret);
		if(ret!=DSPFP_OK)
			return -1;
		ret=DSPFP_PlayFile(local_mplayer_handle);
		printf("DSPFP_PlayFile,ret is %d\n",ret);
		if(ret!=DSPFP_OK)
			return -1;
		local_playstate=PLAYERSTATE_PLAYING;
	}
	else
	{
		ret=DSPFP_SeekFileByTime(local_mplayer_handle,local_playstarttime);
		printf("DSPFP_SeekFileByTime,ret is %d\n",ret);
		if(ret!=DSPFP_OK)
			return -1;
		local_playstate=PLAYERSTATE_PLAYING;
	}
	return 0;
}

int LocalFilePlayer::playByTime(int type, int timestamp,int speed=0)
{
	DSPFP_RETVALUE ret;

	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;

	local_playstarttime=timestamp;
	real_speed=speed;
	if(local_mplayer_handle <=0)
	{	   
		ret=SetPlayerParam();
		if(ret!=DSPFP_OK)
			return -1;
		ret=DSPFP_PlayFile(local_mplayer_handle);
		if(ret!=DSPFP_OK)
			return -1;
		local_playstate=PLAYERSTATE_PLAYING;
	}
	else
	{
		ret=DSPFP_SeekFileByTime(local_mplayer_handle,local_playstarttime);
		if(ret!=DSPFP_OK)
			return -1;
		local_playstate=PLAYERSTATE_PLAYING;
	}

	ret=DSPFP_Play(local_mplayer_handle,DSPFP_Playmode_PlayIFrame,1,real_speed);
	if(ret!=DSPFP_OK)
		return -1;

	if(real_speed>0)
	{
		local_playstate=PLAYERSTATE_FASTFORWARD;
	}
	else if(real_speed<0)
	{
		local_playstate=PLAYERSTATE_FASTBACKWARD;
	}
	return 0;

}

int LocalFilePlayer::pause()
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	ret=DSPFP_Pause(local_mplayer_handle);
	if(ret==DSPFP_OK)
		local_playstate=PLAYERSTATE_PAUSED;
	return 0;
}

int LocalFilePlayer::fastForward(int speed)
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	real_speed=speed;
	ret=DSPFP_Play(local_mplayer_handle,DSPFP_Playmode_PlayIFrame,1,real_speed);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_FASTFORWARD;
	return 0;
}

int LocalFilePlayer::fastRewind(int speed)
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	real_speed=speed;
	ret=DSPFP_Play(local_mplayer_handle,DSPFP_Playmode_PlayIFrame,1,real_speed);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_FASTBACKWARD;
	return 0;
}


int LocalFilePlayer::resume()
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	real_speed=0;
	ret=DSPFP_Play(local_mplayer_handle,DSPFP_Playmode_PlayIFrame,1,real_speed);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_PLAYING;
	return 0;
}

int LocalFilePlayer::gotoEnd()
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	local_playstarttime=local_duration;
	ret=DSPFP_SeekFileByTime(local_mplayer_handle,local_playstarttime);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_PLAYING;
	return 0;
}

/*跳到媒体起始点播放*/
int LocalFilePlayer::gotoStart()
{
	DSPFP_RETVALUE ret;
	if(real_allowTrickmodeFlag)// 1:不允许trickmode
		return -1;
	if(local_mplayer_handle <=0)
		return -1;
	local_playstarttime=0;
	ret=DSPFP_SeekFileByTime(local_mplayer_handle,local_playstarttime);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_PLAYING;
	return 0;
}


/*停止正在播放的媒体。并释放机顶盒本地播放器的相关资源。*/
int LocalFilePlayer::stop()
{
	DSPFP_RETVALUE ret;
	if(local_mplayer_handle <=0)
		return -1;
	ret=DSPFP_StopPlayer(local_mplayer_handle);
	if(ret!=DSPFP_OK)
		return -1;
	ret=DSPFP_ClosePlayer(local_mplayer_handle);
	if(ret!=DSPFP_OK)
		return -1;
	local_playstate=PLAYERSTATE_STOPED;
	return 0;
}

int LocalFilePlayer::player_setwindowparms(int top, int left, int width, int height)
{
	DSPFP_RETVALUE ret;
	if(local_mplayer_handle <=0)
		return -1;
	Playparms.playwindow.height=height*PLAYER_Full_Win_HEGHT/DFB_OSD_HEIGHT;
	Playparms.playwindow.width=width*PLAYER_Full_Win_WIDTH/DFB_OSD_WIDTH;
	Playparms.playwindow.x=top*PLAYER_Full_Win_WIDTH/DFB_OSD_WIDTH;
	Playparms.playwindow.y=left*PLAYER_Full_Win_HEGHT/DFB_OSD_HEIGHT;
	ret=DSPFP_SetPlayerLocation(local_mplayer_handle,Playparms.playwindow);
	if(ret!=DSPFP_OK)
		return -1;
	return 0;
}

int LocalFilePlayer::switchAudioChannel()
{
	DSPFP_RETVALUE ret;
	if(local_mplayer_handle <=0)
		return -1;

	if(local_audiomode == DSPDualMode_Stereo)
		local_audiomode=DSPDualMode_LeftMono;
	else if(local_audiomode == DSPDualMode_LeftMono)
		local_audiomode=DSPDualMode_RightMono;
	else if(local_audiomode == DSPDualMode_RightMono)
		local_audiomode=DSPDualMode_MixMono;
	else if(local_audiomode == DSPDualMode_MixMono)
		local_audiomode=DSPDualMode_Stereo;
	
	ret=DSPFP_SetAudiomode(local_mplayer_handle, local_audiomode);
	if(ret==DSPFP_OK)
		return 0;
	else 
		return -1;
}


int LocalFilePlayer::IX_CheckSubEncode()
{
	FILE *fp=NULL;
	unsigned char t1,t2,t3;
	//printf("filepath=%s\n",gTextSub.subfilepath);
	if(NULL==(fp=fopen(gTextSub.subfilepath,"r")))
	{
		printf("open sub file failed.\n");
		return -1;
	}
	fread(&t1,1,1,fp);
	fread(&t2,1,1,fp);
	fread(&t3,1,1,fp);
	if(t1==0xef&&t2==0xbb&&t3==0xbf)
		gTextSub.subfileencode=4;
	else if(t1==0xfe&&t2==0xff)
		gTextSub.subfileencode=2;
	else if(t1==0xff&&t2==0xfe)
		gTextSub.subfileencode=3;
	else
		gTextSub.subfileencode=1;
	fclose(fp);
	//printf("file encode is %d\n",gTextSub.subfileencode);
	return gTextSub.subfileencode;
}


int LocalFilePlayer::SubLoadNext()
{
	char rem_url[IX_MAX_FILENAME_LENGTH];
	int flag=0;
	if(gTextSub.subfilepath)
	{
		strcpy(rem_url,gTextSub.subfilepath);
	}
	else
		flag=1;
	//字幕切换顺序 chs.srt srt cht.srt ass ssa eng.srt pass不存在的
	printf("sub type is %d\n",gTextSub.subfiletype);
	switch(gTextSub.subfiletype)
	{
		case 1://chs.srt next srt
			if(gTextSub.substat&0x08)
			{
				gTextSub.subfiletype=2;
				gTextSub.subfilepath=gTextSub.subfilepathsrt;
			}
			else if(gTextSub.substat&0x02)
			{
				gTextSub.subfiletype=5;
				gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
			}
			else if(gTextSub.substat&0x10)
			{
				gTextSub.subfiletype=3;
				gTextSub.subfilepath=gTextSub.subfilepathass;
			}
			else if(gTextSub.substat&0x20)
			{
				gTextSub.subfiletype=4;
				gTextSub.subfilepath=gTextSub.subfilepathssa;
			}
			else if(gTextSub.substat&0x04)
			{
				gTextSub.subfiletype=6;
				gTextSub.subfilepath=gTextSub.subfilepathengsrt;
			}
			else
			{//only 1 sub
				//
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
		case 2://srt
			if(gTextSub.substat&0x02)
			{
				gTextSub.subfiletype=5;
				gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
			}
			else if(gTextSub.substat&0x10)
			{
				gTextSub.subfiletype=3;
				gTextSub.subfilepath=gTextSub.subfilepathass;
			}
			else if(gTextSub.substat&0x20)
			{
				gTextSub.subfiletype=4;
				gTextSub.subfilepath=gTextSub.subfilepathssa;
			}
			else if(gTextSub.substat&0x04)
			{
				gTextSub.subfiletype=6;
				gTextSub.subfilepath=gTextSub.subfilepathengsrt;
			}
			else if(gTextSub.substat&0x1)
			{
				gTextSub.subfiletype=1;
				gTextSub.subfilepath=gTextSub.subfilepathchssrt;
			}
			else
			{//only 1 sub
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
		case 3://ass
			if(gTextSub.substat&0x20)
			{
				gTextSub.subfiletype=4;
				gTextSub.subfilepath=gTextSub.subfilepathssa;
			}
			else if(gTextSub.substat&0x04)
			{
				gTextSub.subfiletype=6;
				gTextSub.subfilepath=gTextSub.subfilepathengsrt;
			}
			else if(gTextSub.substat&0x01)
			{
				gTextSub.subfiletype=1;
				gTextSub.subfilepath=gTextSub.subfilepathchssrt;
			}
			else if(gTextSub.substat&0x08)
			{
				gTextSub.subfiletype=2;
				gTextSub.subfilepath=gTextSub.subfilepathsrt;
			}
			else if(gTextSub.substat&0x02)
			{
				gTextSub.subfiletype=5;
				gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
			}
			else
			{//only 1 sub
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
		case 4://ssa
			if(gTextSub.substat&0x04)
			{
				gTextSub.subfiletype=6;
				gTextSub.subfilepath=gTextSub.subfilepathengsrt;
			}
			else if(gTextSub.substat&0x01)
			{
				gTextSub.subfiletype=1;
				gTextSub.subfilepath=gTextSub.subfilepathchssrt;
			}
			else if(gTextSub.substat&0x08)
			{
				gTextSub.subfiletype=2;
				gTextSub.subfilepath=gTextSub.subfilepathsrt;
			}
			else if(gTextSub.substat&0x02)
			{
				gTextSub.subfiletype=5;
				gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
			}
			else if(gTextSub.substat&0x10)
			{
				gTextSub.subfiletype=3;
				gTextSub.subfilepath=gTextSub.subfilepathass;
			}
			else
			{//only 1 sub
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
		case 5://cht.srt
			if(gTextSub.substat&0x10)
			{
				gTextSub.subfiletype=3;
				gTextSub.subfilepath=gTextSub.subfilepathass;
			}
			else if(gTextSub.substat&0x20)
			{
				gTextSub.subfiletype=4;
				gTextSub.subfilepath=gTextSub.subfilepathssa;
			}
			else if(gTextSub.substat&0x04)
			{
				gTextSub.subfiletype=6;
				gTextSub.subfilepath=gTextSub.subfilepathengsrt;
			}
			else if(gTextSub.substat&0x01)
			{
				gTextSub.subfiletype=1;
				gTextSub.subfilepath=gTextSub.subfilepathchssrt;
			}
			else if(gTextSub.substat&0x08)
			{
				gTextSub.subfiletype=2;
				gTextSub.subfilepath=gTextSub.subfilepathsrt;
			}
			else
			{//only 1 sub
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
		case 6://eng.srt
			if(gTextSub.substat&0x01)
			{
				gTextSub.subfiletype=1;
				gTextSub.subfilepath=gTextSub.subfilepathchssrt;
			}
			else if(gTextSub.substat&0x08)
			{
				gTextSub.subfiletype=2;
				gTextSub.subfilepath=gTextSub.subfilepathsrt;
			}
			else if(gTextSub.substat&0x02)
			{
				gTextSub.subfiletype=5;
				gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
			}
			else if(gTextSub.substat&0x10)
			{
				gTextSub.subfiletype=3;
				gTextSub.subfilepath=gTextSub.subfilepathass;
			}
			else if(gTextSub.substat&0x20)
			{
				gTextSub.subfiletype=4;
				gTextSub.subfilepath=gTextSub.subfilepathssa;
			}
			else
			{//only 1 sub
				if(gTextSub.subfilepath&&!flag)
				{
					gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
				}
				else
					gTextSub.flag_sub_changed=0;
				return gTextSub.subfiletype;
			}
			break;
	}
	if(gTextSub.subfilepath&&!flag)
	{
		gTextSub.flag_sub_changed=strcmp(rem_url,gTextSub.subfilepath);
	}
	else
		gTextSub.flag_sub_changed=0;
	//IX_ClearSub();
	memset(gTextSub.subline,0,sizeof(gTextSub.subline));
	IX_CheckSubEncode();
	return gTextSub.subfiletype;
}
int LocalFilePlayer::IX_HasSubChsSrt(char *path)
{//存在返回1 不存在返回0
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename)!=NULL) && (strstr(c->d_name,".chinese.srt") != NULL ||strstr(c->d_name,".CHINESE.srt") != NULL || strstr(c->d_name,".CHINESE.SRT") != NULL \
				|| strstr(c->d_name,".chs.srt") != NULL || strstr(c->d_name,".Chs.srt") != NULL || strstr(c->d_name,".CHS.srt") != NULL \
				|| strstr(c->d_name,".CHS.SRT") != NULL || strstr(c->d_name,".Chs.SRT") != NULL||strstr(c->d_name,".Chs.Srt") != NULL\
				||strstr(c->d_name,".gb.srt") != NULL\
				||strstr(c->d_name,".GB.SRT") != NULL||strstr(c->d_name,".Gb.Srt") != NULL))			                                                            
			{
				memset(gTextSub.subfilepathchssrt,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathchssrt,"%s%s",dirpath,c->d_name);
				closedir(d);
				printf("gTextSub.subfilepathchssrt=%s\n",gTextSub.subfilepathchssrt);
				return 1;
			}			
		}
	}
	closedir(d);
	
	return 0;
	
}

int LocalFilePlayer::IX_HasSubChtSrt(char *path)
{
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename)!=NULL) && (\
			     strstr(c->d_name,".cht.srt") != NULL || strstr(c->d_name,".Cht.srt") != NULL || strstr(c->d_name,".CHT.srt") != NULL \
				|| strstr(c->d_name,".CHT.SRT") != NULL || strstr(c->d_name,".Cht.SRT") != NULL||strstr(c->d_name,".Cht.Srt") != NULL\
				||strstr(c->d_name,".big5.srt") != NULL||strstr(c->d_name,".Big5.Srt") != NULL||strstr(c->d_name,".BIG5.SRT") != NULL))				                                                            
			{
				memset(gTextSub.subfilepathchtsrt,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathchtsrt,"%s%s",dirpath,c->d_name);
				closedir(d);
				return 1;
			}			
		}
	}
	closedir(d);
	return 0;
}

int LocalFilePlayer::IX_HasSubEngSrt(char *path)
{
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename)!=NULL) && (strstr(c->d_name,".english.srt") != NULL ||strstr(c->d_name,".ENGLISH.srt") != NULL || strstr(c->d_name,".ENGLISH.SRT") != NULL \
				|| strstr(c->d_name,".eng.srt") != NULL || strstr(c->d_name,".Eng.srt") != NULL || strstr(c->d_name,".ENG.srt") != NULL \
				|| strstr(c->d_name,".ENG.SRT") != NULL || strstr(c->d_name,".Eng.SRT") != NULL||strstr(c->d_name,".Eng.Srt") != NULL||strstr(c->d_name,".En.Srt") != NULL||strstr(c->d_name,".en.srt") != NULL\
				||strstr(c->d_name,".EN.SRT") != NULL))                                                            
			{
				memset(gTextSub.subfilepathengsrt,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathengsrt,"%s%s",dirpath,c->d_name);
				closedir(d);
				printf("gTextSub.subfilepathengsrt=%s\n",gTextSub.subfilepathengsrt);
				return 1;
			}			
		}
	}
	closedir(d);
	return 0;
}

int LocalFilePlayer::IX_HasSubSrt(char *path)
{//存在返回1 不存在返回0
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char subfilename1[IX_MAX_FILENAME_LENGTH];
	char subfilename2[IX_MAX_FILENAME_LENGTH];
	char subfilename3[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	strcpy(subfilename1,subfilename);
	strcat(subfilename1,".srt");
	strcpy(subfilename2,subfilename);
	strcat(subfilename2,".Srt");
	strcpy(subfilename3,subfilename);
	strcat(subfilename3,".SRT");// for precise match
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename1)!=NULL) || \
				 strstr(c->d_name,subfilename2) != NULL || strstr(c->d_name,subfilename3) != NULL )			                                                            
			{
				memset(gTextSub.subfilepathsrt,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathsrt,"%s%s",dirpath,c->d_name);
				closedir(d);
				return 1;
			}			
		}
	}
	closedir(d);
	return 0;
}

int LocalFilePlayer::IX_HasSubAss(char *path)
{//存在返回1 不存在返回0
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename)!=NULL) && (strstr(c->d_name,".ass") != NULL \
				|| strstr(c->d_name,".Ass") != NULL || strstr(c->d_name,".ASS") != NULL ))			                                                            
			{
				memset(gTextSub.subfilepathass,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathass,"%s%s",dirpath,c->d_name);
				closedir(d);
				return 1;
			}			
		}
	}
	closedir(d);
	return 0;
}
int LocalFilePlayer::IX_HasSubSsa(char *path)
{//存在返回1 不存在返回0
	char subfilepath[IX_MAX_FILENAME_LENGTH];
	char subfilename[IX_MAX_FILENAME_LENGTH];
	char dirpath[IX_MAX_FILENAME_LENGTH];
	int subpathlength;
	int cnt=0;
	DIR *d;
	struct dirent *c;
	
	strcpy(subfilepath,path);
	subpathlength=strlen(path);
	while(subfilepath[--subpathlength]!='.'){;}
	subfilepath[subpathlength]=0;
	
	strcpy(dirpath,path);
	while(dirpath[--subpathlength]!='/'){;}
	dirpath[subpathlength+1]=0;

	while(subfilepath[++subpathlength]!=0)
	{
		subfilename[cnt++]=subfilepath[subpathlength];
	}
	subfilename[cnt]=0;
	
	d = opendir(dirpath);
	if(d != NULL) 
	{
		while((c = readdir(d))!= NULL)
		{
			if((!strcmp(c->d_name, ".")) || (!strcmp(c->d_name, "..")))
				continue;
			
			if((strstr(c->d_name,subfilename)!=NULL) && (strstr(c->d_name,".ssa") != NULL \
				|| strstr(c->d_name,".Ssa") != NULL || strstr(c->d_name,".SSA") != NULL ))			                                                            
			{
				memset(gTextSub.subfilepathssa,0,sizeof(gTextSub.subfilepath));
				sprintf(gTextSub.subfilepathssa,"%s%s",dirpath,c->d_name);
				closedir(d);
				return 1;
			}			
		}
	}
	closedir(d);
	return 0;
}

int LocalFilePlayer::IX_SubExist(char *path)
{//存在返回非零值 不存在返回0
        if(!path||path[0]=='\0')
            return 0;
	printf("video path is %s.\n",path);
	//scan all sub file
	subfileSum=0;
	if(IX_HasSubChsSrt(path))
	{
		gTextSub.substat|=0x1;
		subfileSum++;
	}
	if(IX_HasSubChtSrt(path))
	{
		gTextSub.substat|=0x2;
		subfileSum++;
	}
	if(IX_HasSubEngSrt(path))
	{
		gTextSub.substat|=0x4;
		subfileSum++;
	}
	if(IX_HasSubSrt(path))
	{
		gTextSub.substat|=0x8;
		subfileSum++;
	}
	if(IX_HasSubAss(path))
	{
		gTextSub.substat|=0x10;
		subfileSum++;
	}
	if(IX_HasSubSsa(path))
	{
		gTextSub.substat|=0x20;
		subfileSum++;
	}
	//
	printf("subfilesum=%d\n",subfileSum);
	printf("IX_SubExist gTextSub.subfilepathchssrt=%s\n",gTextSub.subfilepathchssrt);
	printf("IX_SubExist gTextSub.subfilepathengsrt=%s\n",gTextSub.subfilepathengsrt);
	if(gTextSub.substat&0x01)
	{//.chs.srt
		gTextSub.subfiletype=1;
		gTextSub.subfilepath=gTextSub.subfilepathchssrt;
	}
	else if(gTextSub.substat&0x08)
	{//.srt
		gTextSub.subfiletype=2;
		gTextSub.subfilepath=gTextSub.subfilepathsrt;//sub default
	}
	else if(gTextSub.substat&0x02)
	{//cht.srt
		gTextSub.subfiletype=5;
		gTextSub.subfilepath=gTextSub.subfilepathchtsrt;
	}
	else if(gTextSub.substat&0x10)
	{
		//ass
		gTextSub.subfiletype=3;
		gTextSub.subfilepath=gTextSub.subfilepathass;
	}
	else if(gTextSub.substat&0x20)
	{
		//ssa
		gTextSub.subfiletype=4;
		gTextSub.subfilepath=gTextSub.subfilepathssa;
	}
	else if(gTextSub.substat&0x04)
	{//英文字幕最后测 .eng.srt
		gTextSub.subfiletype=6;
		gTextSub.subfilepath=gTextSub.subfilepathengsrt;
	}
	
	else
		gTextSub.subfiletype=0;//no sub.
	printf("IX_SubExist gTextSub.subfilepath=%s\n",gTextSub.subfilepath);
	
	if(gTextSub.subfiletype)
		IX_CheckSubEncode();
	
	return gTextSub.subfiletype;
}

void LocalFilePlayer::IX_stripNL(FILE *fp,int c)
{//本函数滤去多余的回车符\r or \n when both exist
	int cc;
	unsigned short data;
	switch(gTextSub.subfileencode)
	{
	case 1://multibyte 
	case 4://utf8
		cc=fgetc(fp);
		if(cc==EOF)
			return;	
		if(c=='\r'&&cc=='\n')
			return;
		if(c=='\n'&&cc=='\r')
			return;
		fseek(fp,-1,SEEK_CUR);
		break;
	case 2://unicode16 big
		cc=fread(&data,2,1,fp);
		if(cc==0)
			return;
		if(c==0x0d00&&data==0x0a00)
			return;
		if(c==0x0a00&&data==0x0d00)
			return;
		fseek(fp,-2,SEEK_CUR);
		break;
	case 3://unicode 16 little
		cc=fread(&data,2,1,fp);
		//printf("strip data=%d\n",data);
		if(cc==0)
			return;
		if(c==0x000d&&data==0x000a)
			return;
		if(c==0x000a&&data==0x000d)
			return;
		
		fseek(fp,-2,SEEK_CUR);
		break;
	}
	
}

void LocalFilePlayer::IX_Big5toGbk(char *buffer)
{//把一个big5编码的串转成gbk
	unsigned short word;
	while(*buffer)
	{
		if(*buffer&0x80)
		{
			word=0;
			word=(unsigned char)(*buffer);
			word|=((unsigned char)(*(buffer+1)))<<8;
			word=Big5toGbk(word);
			*buffer=word&0x00ff;
			*(buffer+1)=(word>>8)&0x00ff;
			buffer+=2;
		}
		else
		{
			//nothing.
			buffer++;
		}
		
	}
}
void  LocalFilePlayer::UnicodeBigToLittle(char *src)
{
	unsigned short *psrc=(unsigned short *)src;
	unsigned char temp;
	while(*psrc)
	{
		temp=(*psrc)&0x00ff;
		(*psrc)=((*psrc)>>8)&0x00ff;
		(*psrc)|=(temp<<8);
		psrc++;
	}
	return;
}
void  LocalFilePlayer::IX_Uni16LittleToUtf8(char *src,char *dest)
{//本函数不检查溢出 src要以0x00 0x00 finish
	unsigned short *psrc=(unsigned short *)src;
	int srccnt=0,destcnt=0;
	//printf("begin.");
	while(psrc[srccnt]!=0)
	{
		if(psrc[srccnt]<=0x7f)
		{
			dest[destcnt++]=psrc[srccnt];
		}
		else if(psrc[srccnt]<=0x7ff)
		{
			dest[destcnt++]=((psrc[srccnt]>>6)&0x1f)|0xc0;
			dest[destcnt++]=(psrc[srccnt]&0x3f)|0x80;
		}
		else if(psrc[srccnt]<=0xffff)
		{
			dest[destcnt++]=((psrc[srccnt]>>12)&0x0f)|0xe0;
			dest[destcnt++]=((psrc[srccnt]>>6)&0x3f)|0x80;
			dest[destcnt++]=(psrc[srccnt]&0x3f)|0x80;
		}
		//以下三种now不可能
		//else if(psrc[srccnt]<0x1fffff)
		//{
		//}
		//else if(psrc[srccnt]<0x3ffffff)
		//{
		//}
		//else if(psrc[srccnt]<0x7fffffff)
		//{	
		//}
		srccnt++;
	}
	dest[destcnt]=0;
	//printf("over");
	return;
}
void  LocalFilePlayer::IX_Uni16BigToUtf8(char *src,char *dest)
{//本函数不检查溢出 src要以0x00 0x00 finish
	//大端模式高位在前 ascii 00 xx 
	//to little endian
	UnicodeBigToLittle(src);
	IX_Uni16LittleToUtf8(src,dest);
	return;
}

int LocalFilePlayer::IX_SubReadLine(FILE *fp,char *buffer,int size)
{//当读至文件尾返回 0 else return 1空行 2非空行
	int c;
	int cnt=0;
	int ret=0;
	char buffer2[2048];
	unsigned short data;
	unsigned short *pbuf;
	
	//printf("parse a line.\n");
	memset(buffer,0,size);
	//printf("gTextSub.subfileencode=%d\n",gTextSub.subfileencode);
	switch(gTextSub.subfileencode)
	{
		case 1://multibyte read a line
		case 4://utf8 read a line	
			c=fgetc(fp);
			if(c==EOF)
				return 0;
			if(c=='\r'||c=='\n')
			{
				//这是一空行
				IX_stripNL(fp,c);
				ret=1;
				return ret;
			}

			while(c!='\r'&&c!='\n')
			{
				buffer[cnt++]=c;
				//zhanghs adds
				if(cnt>=2048)
				{
					//one line is too long, there would be an error.
					printf("the characters of one line surpass 2048-zhanghs\n");
					return 0;
				}
				//zhanghs adds
				c=fgetc(fp);
				if(c==EOF)
				{	
					ret=2;
					goto _convert;
				}//这是最后一行 无换行	
			}
			IX_stripNL(fp,c);
			ret=2;
			break;
		case 2://unicode 16 bigendian read a line
			pbuf=(unsigned short *)buffer;
			c=fread(&data,2,1,fp);
			if(c==0)
				return 0;//read over.
			if(data==0x0d00||data==0x0a00)
			{
				//这是一空行
				IX_stripNL(fp,data);
				ret=1;
				return ret;
			}

			while(data!=0x0d00&&data!=0x0a00)
			{
				pbuf[cnt++]=data;
				c=fread(&data,2,1,fp);
				if(c==0)
				{	
					ret=2;
					goto _convert;
				}//这是最后一行 无换行
			}
			IX_stripNL(fp,data);
			ret=2;
			break;
		case 3://unicode 16 littleendian read a line
			//printf("little endian read line.\n");
			pbuf=(unsigned short *)buffer;
			c=fread(&data,2,1,fp);
			//printf("data=%d\n",data);
			if(c==0)
				return 0;//read over.
			if(data==0x000d||data==0x000a)
			{
				//这是一空行
				IX_stripNL(fp,data);
				ret=1;
				return ret;
			}

			while(data!=0x000d&&data!=0x000a)
			{
				pbuf[cnt++]=data;
				c=fread(&data,2,1,fp);
			//	printf("data=%d\n",data);
				if(c==0)
				{	
					ret=2;
					goto _convert;
				}//这是最后一行 无换行
			}
			IX_stripNL(fp,data);
			ret=2;
			break;
	}

_convert:
	memset(buffer2,0,2048);
	//printf("get middle.\n");
//	if(buffer[0])//wrong!
	{//转成UTF-8
		switch(gTextSub.subfileencode)
		{
		case 1:
		//	printf("before this call %s\n ",buffer);
			if(gTextSub.subfiletype==5)
			{
				//繁体字幕 先从big5转成gbk
				IX_Big5toGbk(buffer);
			}
			//printf("buffer=%s\n",buffer);
			//IXMachineToUtf8_Gbk(buffer,(unsigned char *)buffer2);
			//printf("buffer2=%s\n",buffer2);
		//	printf("call over.\n");
			//memset(buffer,0,size);
			//strcpy(buffer,buffer2);
			break;
		case 2:
			IX_Uni16BigToUtf8(buffer,buffer2);
			memset(buffer,0,size);
			strcpy(buffer,buffer2);
			break;
		case 3:
			//printf("before convert.\n");
			IX_Uni16LittleToUtf8(buffer,buffer2);
			memset(buffer,0,size);
			strcpy(buffer,buffer2);
			u2g(buffer2,strlen(buffer2),buffer,size-1);
			break;
		case 4:
			break;
		}
	}
	//去掉前导空格
	cnt=0;
	while(buffer[cnt++]==' '){;}
	if(cnt>1)
	{//move
		c=0;
		while(buffer[cnt-1+c])
		{
			buffer[c]=buffer[cnt-1+c];
			c++;
		}
		buffer[c]=0;
	}
	//printf("buffer:%s\n",buffer);
	//printf("parse a line over.\n");
	return ret;//error 
}

void LocalFilePlayer::IX_ParseSrtDialog(char *buffer,char *text)
{
	//去掉修饰字符 
	//滤掉所有<...>修饰
#define ACT_WRITE 0
#define ACT_STRIP 1

	int cnt=0,destcnt=0;
	int action=ACT_WRITE;
	
	memset(text,0,MAX_SUBTITLE_STRLEN);
	
	while(buffer[cnt])
	{
		if(buffer[cnt]=='<')
			action=ACT_STRIP;

		if(buffer[cnt]=='{')
			action=ACT_STRIP;

		switch(action)
		{
			case ACT_WRITE:
				text[destcnt++]=buffer[cnt];
				break;
			case ACT_STRIP:
				//strip
				if(buffer[cnt]=='>')
					action=ACT_WRITE;
				if(buffer[cnt]=='}')
					action=ACT_WRITE;
				break;
		}
		cnt++;
	}
	/*zhanghs' revise to center subtilte*/
	int subline_length=0;
	subline_length=strlen(text);
	int maxwords_line=IX_SCREEN_WIDTH/40;  
	int needblanks=10;  //base blanks, it's a experiential value
	if (maxwords_line>subline_length)
	{
		needblanks+=(maxwords_line-subline_length);
	}
	while(subline_length--)
	{
		text[subline_length+needblanks]=text[subline_length];
	}
	while(needblanks--)
	{
		text[needblanks]=' ';
	}
	/*zhanghs' revise end*/
}

void LocalFilePlayer::IX_ParseSrtTime(char *buffer,int *start,int *end)
{
	long hour,min,sec,mili;
	char *p;
	//printf("parse srt time.\n");
	
	p=strtok(buffer,":");
	hour=strtol(p,NULL,10);
	//printf("s hour:%ld",hour);
	p=strtok(NULL,":");
	min=strtol(p,NULL,10);
	//printf("s min:%ld",min);
	p=strtok(NULL,",");
	sec=strtol(p,NULL,10);
	//printf("s sec:%ld",sec);
	p=strtok(NULL,">");
	mili=strtol(p,NULL,10);
	//printf("s mili:%ld",mili);
	*start=hour*3600000+min*60000+sec*1000+mili;

	p=strtok(NULL,":");
	hour=strtol(p,NULL,10);
	//printf(" e hour:%ld",hour);
	p=strtok(NULL,":");
	min=strtol(p,NULL,10);
	//printf("e min:%ld",min);
	p=strtok(NULL,",");
	sec=strtol(p,NULL,10);
	//printf("e sec:%ld",sec);
	p=strtok(NULL," ");
	mili=strtol(p,NULL,10);
	//printf("e mili:%ld",mili);
	*end=hour*3600000+min*60000+sec*1000+mili;
	//printf("parse srt time over\n");
	return;
}

void LocalFilePlayer::IX_ParseSubSrt()
{
#define ST_READ_NUM  0
#define ST_READ_TIME 1
#define ST_READ_DIALOG 2

	FILE *fp=NULL;
	char buffer[2048];
	char State=ST_READ_NUM;
	int cnt=0;
	int line=0;
	printf("IX_ParseSubSrt gTextSub.subfilepath=%s\n",gTextSub.subfilepath);
	if(NULL==(fp=fopen(gTextSub.subfilepath,"r")))
	{
		printf("open sub file failed.\n");
		return;
	}
	if(gTextSub.subfileencode==1)
		;//nothing to do
	else if(gTextSub.subfileencode==2||gTextSub.subfileencode==3)
		fread(buffer,1,2,fp);//strip two bytes
	else if(gTextSub.subfileencode==4)
		fread(buffer,1,3,fp);//strip three bytes
		
	//printf("gTextSub.subfileencode=%d\n",gTextSub.subfileencode);
	
	while(IX_SubReadLine(fp,buffer,2048))
	{
		/*******2011.04.19 防止字幕行数过多死机******/
		if(line>=MAX_SUBTITLE_SRTLINES)
		{
			printf("over lines\n");
			break;
		}
		line++;
		/*************************************/
		//printf("buffer:%s,state:%d\n",buffer,State);
		switch(State)
		{
		case ST_READ_NUM:

			if(buffer[0]==0)
				break;
			else{
				//strtoul(buffer,NULL,0);	
				State++;
			}
			break;
		case ST_READ_TIME:
			/* to check whether it is time since some subtitles may be irregular,  this additional judgement will tolerate some errors*/
			if(strchr(buffer,':')==NULL)	//cannot find the character ':' which should be found in the time line, zhanghs adds
			{
				State=ST_READ_NUM;
				break;
			}
			/* zhanghs's addition end*/
			IX_ParseSrtTime(buffer,(int*)(&gTextSub.subline[gTextSub.sublinesum].start),\
								   (int*)(&gTextSub.subline[gTextSub.sublinesum].end));
			State++;
			break;
		case ST_READ_DIALOG:
			if(buffer[0]==0)
			{
				State=ST_READ_NUM;
				cnt=0;
				gTextSub.sublinesum++;
				break;
			}
			IX_ParseSrtDialog(buffer,gTextSub.subline[gTextSub.sublinesum].text[cnt++]);
			break;
		}
	}
	
	fclose(fp);
	printf("parse srt over.\n");
	return;
}

void LocalFilePlayer::IX_ParseAssDialog(char *buffer)
{
	char *pbuf,*pbuf2,*pbuf3;
	int hour,min;
	double sec;
	int cnt=0,state=0,destcnt=0;

	if(*buffer==0)
		return;//blank line
	
	if(!strncmp(buffer,"Dialogue",8))
	{//parse it others all miss
		//printf("buffer:%s[over]\n",buffer);
		pbuf=buffer;
		for(;cnt<9;cnt++)
		{
			pbuf=strstr(pbuf,",");//找到第九个
			if(pbuf==NULL)
			{
				printf(", not enough.\n");
				return;//format wrong.
			}
			else
				pbuf++;
		}
		cnt=0;
		pbuf3=pbuf;//point to dialogue
		
		pbuf=strstr(buffer,",");
		pbuf++;//point to start time now
		pbuf2=strtok(pbuf,":");
		hour=atoi(pbuf2);
		pbuf2=strtok(NULL,":");
		min=atoi(pbuf2);
		pbuf2=strtok(NULL,",");
		sec=atof(pbuf2);
		gTextSub.subline[gTextSub.sublinesum].start=hour*3600000+min*60000+(int)(sec*1000);
		
		//end time
		pbuf2=strtok(NULL,":");
		hour=atoi(pbuf2);
		pbuf2=strtok(NULL,":");
		min=atoi(pbuf2);
		pbuf2=strtok(NULL,",");
		sec=atof(pbuf2);
		gTextSub.subline[gTextSub.sublinesum].end=hour*3600000+min*60000+(int)(sec*1000);

		//to here point to dialogue
		pbuf=pbuf3;
		//printf("%s\n",pbuf);
		//parse this ...
#define ASS_ST_READ 0
#define ASS_ST_STRIP 1
#define ASS_ST_JUMP 2
		while(*pbuf)
		{
			if(*pbuf=='{')
				state=ASS_ST_STRIP;
			
			switch(state)
			{
			case ASS_ST_READ:
				if(*pbuf==0x5c)
				{
					state=ASS_ST_JUMP;
				}
				else
				{
					gTextSub.subline[gTextSub.sublinesum].text[cnt][destcnt++]=*pbuf;
				}
				break;
			case ASS_ST_STRIP:
				if(*pbuf=='}')
					state=ASS_ST_READ;
				break;
			case ASS_ST_JUMP:
				if(*pbuf=='h'||*pbuf=='n')
					gTextSub.subline[gTextSub.sublinesum].text[cnt][destcnt++]=' ';
				if(*pbuf=='N')
				{
					gTextSub.subline[gTextSub.sublinesum].text[cnt][destcnt]=0;
					cnt++;
					destcnt=0;
				}
				state=ASS_ST_READ;
				break;
			}
			pbuf++;
		}
		gTextSub.sublinesum++;
		
	}
	return;
}
void LocalFilePlayer::IX_ParseSubAss()
{
//ass is V4+style ssa V4 style
//因此如果要实现文本的各种效果 分开它们 因为修饰符意义不同
//本代码一样处理，因为我无视了所有效果，只提取时间与字幕
	FILE *fp=NULL;
	char buffer[2048];
	int line=0;
	printf("IX_ParseSubAss() gTextSub.subfilepath=%s\n",gTextSub.subfilepath);
	if(NULL==(fp=fopen(gTextSub.subfilepath,"r")))
	{
		printf("open sub file failed.\n");
		return;
	}
	
	if(gTextSub.subfileencode==1)
		;//nothing to do
	else if(gTextSub.subfileencode==2||gTextSub.subfileencode==3)
		fread(buffer,1,2,fp);//strip two bytes
	else if(gTextSub.subfileencode==4)
		fread(buffer,1,3,fp);//strip three bytes
		
	//printf("gTextSub.subfileencode=%d\n",gTextSub.subfileencode);
	
	while(IX_SubReadLine(fp,buffer,2048))
	{
		/*******2011.04.19 防止字幕行数过多死机******/
		if(line>=MAX_SUBTITLE_SRTLINES)
		{
			printf("over lines\n");
			break;
		}
		line++;
		/*************************************/
		//printf("buffer:%s\n",buffer);
		IX_ParseAssDialog(buffer);
	}
	
	fclose(fp);
	printf("parse sub ass over.sub sum %d\n",gTextSub.sublinesum);
	return;
}

void LocalFilePlayer::IX_ParseSubSsa()
{
	IX_ParseSubAss();//ass 兼容ssa解析一样 见上
	return;
}

void LocalFilePlayer::IX_ParseSub()
{
	gTextSub.sublinesum=0;
	gTextSub.showindex=-1;
	line1.in_use=0;
	line2.in_use=0;
	line1.line_num=0;
	line2.line_num=0;
	switch(gTextSub.subfiletype)
	{
		case 1://chs.srt
		case 2://srt 
		case 5://cht.srt
		case 6://eng.srt
			printf("srt file.\n");
			IX_ParseSubSrt();
			break;
		case 3://ass
			printf("ass file.\n");
			IX_ParseSubAss();
			break;
		case 4://ssa
			printf("ssa file.\n");
			IX_ParseSubSsa();
			break;			
	}
	return;
}
void LocalFilePlayer::IX_SubEnable()
{
	gTextSub.flag_sub_changed=1;
	if(gTextSub.subfiletype!=0&&gTextSub.subDisable==1)
		gTextSub.subDisable=0;
	
}

int LocalFilePlayer::switchSubtitle()
{
	if(local_mplayer_handle<=0)
		return -1;
	if(IX_SubExist(Playparms.url))
	{
		IX_ParseSub();
		IX_SubEnable();
		gTextSub.flag_sub_changed=1;
	}
	if(subfileSum==0)
		return -1;
	if(gTextSub.subcnt==subfileSum-1)
	{
		//it's time to disable
		gTextSub.subDisable=1;
		gTextSub.subcnt=-1;
		return -1;
	}
	switch(SubLoadNext())
	{
		case 1:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_CHS);
			break;
		case 2:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_SRT);
			break;
		case 3:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_ASS);
			break;
		case 4:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_SSA);
			break;
		case 5:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_CHT);
			break;
		case 6:
			gTextSub.subcnt++;
			//IX_SubEvtDraw(EVENT_SUB_ENG);
			break;
	}				
	return 0;
	
}

int LocalFilePlayer::getMediaDuration()
{
	DSPFP_RETVALUE ret;

	if(local_mplayer_handle<=0)
		return -1;
	ret=DSPFP_GetStreamDuration(local_mplayer_handle,&local_duration);
	if(ret==DSPFP_OK)
		return 0;
	else
		return -1;
}
unsigned long LocalFilePlayer::getCurrentPlayTime()
{
	DSPFP_RETVALUE ret;
	if(local_mplayer_handle<=0)
		return 0;

	ret=DSPFP_GetPlaybackTime(local_mplayer_handle, &local_currenttime);
	if(ret==DSPFP_OK)
		return (unsigned long)local_currenttime;
	else
		return 0;
}
char * LocalFilePlayer::getPlaybackMode()
{
	return NULL;
}

int LocalFilePlayer::GetLastError()
{
	if(local_mplayer_handle<=0)
		return -1;
	return (int)DSPFP_GetLastError(local_mplayer_handle);
}
int LocalFilePlayer::getChannelNum()
{
	return -1;
}
int LocalFilePlayer::setSingleMedia(string mediaStr)
{
	printf("setSingleMediasetSingleMedia in LocalFilePlayer\n");
	real_json_str = mediaStr;
	playFromStart();
	return 0;
}

